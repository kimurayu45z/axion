pub struct HashMap[K, V]
    _keys: Ptr[K]
    _values: Ptr[V]
    _states: Ptr[u8]
    _size: usize
    _cap: usize

impl[K, V] HashMap[K, V]
    fn new() -> HashMap[K, V]
        let m: HashMap[K, V] = HashMap #{_keys: 0 as Ptr[K], _values: 0 as Ptr[V], _states: 0 as Ptr[u8], _size: 0, _cap: 0}
        m

    fn len(self) -> usize
        self._size

    fn is_empty(self) -> bool
        self._size == 0

    fn insert(mut self, key: K, value: V)
        if self._cap == 0
            self._grow()
        if self._size * 10 > self._cap * 7
            self._grow()
        let sz = sizeof[K]()
        let temp = malloc(sz) as Ptr[K]
        temp.write(key)
        let bp = temp as Ptr[u8]
        let mut h: usize = 5381
        let mut hi: usize = 0
        while hi < sz
            h = h * 33 + (bp.offset(hi).read() as usize)
            hi = hi + 1
        free(temp as Ptr[{}])
        let mut idx = h % self._cap
        let mut count: usize = 0
        while count < self._cap
            let state = self._states.offset(idx).read()
            if state == (0 as u8)
                self._keys.offset(idx).write(key)
                self._values.offset(idx).write(value)
                self._states.offset(idx).write(1 as u8)
                self._size = self._size + 1
                return
            if state == (1 as u8)
                if self._keys.offset(idx).read() == key
                    self._values.offset(idx).write(value)
                    return
            idx = (idx + 1) % self._cap
            count = count + 1

    fn get(self, key: K) -> Option[V]
        if self._cap == 0
            return Option[V].None
        let sz = sizeof[K]()
        let temp = malloc(sz) as Ptr[K]
        temp.write(key)
        let bp = temp as Ptr[u8]
        let mut h: usize = 5381
        let mut hi: usize = 0
        while hi < sz
            h = h * 33 + (bp.offset(hi).read() as usize)
            hi = hi + 1
        free(temp as Ptr[{}])
        let mut idx = h % self._cap
        let mut count: usize = 0
        while count < self._cap
            let state = self._states.offset(idx).read()
            if state == (0 as u8)
                return Option[V].None
            if state == (1 as u8)
                if self._keys.offset(idx).read() == key
                    return Option[V].Some(self._values.offset(idx).read())
            idx = (idx + 1) % self._cap
            count = count + 1
        Option[V].None

    fn contains_key(self, key: K) -> bool
        if self._cap == 0
            return false
        let sz = sizeof[K]()
        let temp = malloc(sz) as Ptr[K]
        temp.write(key)
        let bp = temp as Ptr[u8]
        let mut h: usize = 5381
        let mut hi: usize = 0
        while hi < sz
            h = h * 33 + (bp.offset(hi).read() as usize)
            hi = hi + 1
        free(temp as Ptr[{}])
        let mut idx = h % self._cap
        let mut count: usize = 0
        while count < self._cap
            let state = self._states.offset(idx).read()
            if state == (0 as u8)
                return false
            if state == (1 as u8)
                if self._keys.offset(idx).read() == key
                    return true
            idx = (idx + 1) % self._cap
            count = count + 1
        false

    fn remove(mut self, key: K) -> Option[V]
        if self._cap == 0
            return Option[V].None
        let sz = sizeof[K]()
        let temp = malloc(sz) as Ptr[K]
        temp.write(key)
        let bp = temp as Ptr[u8]
        let mut h: usize = 5381
        let mut hi: usize = 0
        while hi < sz
            h = h * 33 + (bp.offset(hi).read() as usize)
            hi = hi + 1
        free(temp as Ptr[{}])
        let mut idx = h % self._cap
        let mut count: usize = 0
        while count < self._cap
            let state = self._states.offset(idx).read()
            if state == (0 as u8)
                return Option[V].None
            if state == (1 as u8)
                if self._keys.offset(idx).read() == key
                    let val = self._values.offset(idx).read()
                    self._states.offset(idx).write(2 as u8)
                    self._size = self._size - 1
                    return Option[V].Some(val)
            idx = (idx + 1) % self._cap
            count = count + 1
        Option[V].None

    fn _grow(mut self)
        let old_cap = self._cap
        let old_keys = self._keys
        let old_values = self._values
        let old_states = self._states
        let mut new_cap = old_cap * 2
        if new_cap < 8
            new_cap = 8
        self._keys = malloc(new_cap * sizeof[K]()) as Ptr[K]
        self._values = malloc(new_cap * sizeof[V]()) as Ptr[V]
        self._states = malloc(new_cap) as Ptr[u8]
        let mut i: usize = 0
        while i < new_cap
            self._states.offset(i).write(0 as u8)
            i = i + 1
        self._cap = new_cap
        self._size = 0
        if old_cap > 0
            let mut j: usize = 0
            while j < old_cap
                if old_states.offset(j).read() == (1 as u8)
                    self.insert(old_keys.offset(j).read(), old_values.offset(j).read())
                j = j + 1
            free(old_keys as Ptr[{}])
            free(old_values as Ptr[{}])
            free(old_states as Ptr[{}])

    fn drop(mut self)
        if self._keys.is_null() == false
            free(self._keys as Ptr[{}])
        if self._values.is_null() == false
            free(self._values as Ptr[{}])
        if self._states.is_null() == false
            free(self._states as Ptr[{}])
