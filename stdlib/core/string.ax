import ffi.*
import str.*

pub struct String
    _ptr: Ptr[u8]
    _len: usize
    _cap: usize

impl String
    fn new() -> String
        String #{_ptr: 0 as Ptr[u8], _len: 0, _cap: 0}

    fn from(s: str) -> String
        let len = s.len()
        if len == 0
            return String.new()
        let buf = malloc(len) as Ptr[u8]
        memcpy(buf as Ptr[{}], s.as_ptr() as Ptr[{}], len)
        String #{_ptr: buf, _len: len, _cap: len}

    fn len(self) -> usize
        self._len

    fn is_empty(self) -> bool
        self._len == 0

    fn push(mut self, s: str)
        let src_len = s.len()
        if src_len == 0
            return
        let new_len = self._len + src_len
        if new_len > self._cap
            let mut new_cap = self._cap * 2
            if new_len > new_cap
                new_cap = new_len
            self._ptr = realloc(self._ptr as Ptr[{}], new_cap) as Ptr[u8]
            self._cap = new_cap
        memcpy(self._ptr.offset(self._len) as Ptr[{}], s.as_ptr() as Ptr[{}], src_len)
        self._len = new_len

    fn as_str(self) -> str
        str_from_raw(self._ptr, self._len)

    fn byte_at(self, i: usize) -> u8
        self._ptr.offset(i).read()

    fn contains(self, s: str) -> bool
        _bytes_contains(self._ptr, self._len, s.as_ptr(), s.len())

    fn starts_with(self, s: str) -> bool
        _bytes_starts_with(self._ptr, self._len, s.as_ptr(), s.len())

    fn ends_with(self, s: str) -> bool
        _bytes_ends_with(self._ptr, self._len, s.as_ptr(), s.len())

    fn substring(self, start: usize, end: usize) -> str
        str_from_raw(self._ptr.offset(start), end - start)

    fn clear(mut self)
        self._len = 0

    fn repeat(self, n: usize) -> String
        let total = self._len * n
        if total == 0
            return String.new()
        let buf = malloc(total) as Ptr[u8]
        let mut i: usize = 0
        while i < n
            memcpy(buf.offset(i * self._len) as Ptr[{}], self._ptr as Ptr[{}], self._len)
            i = i + 1
        String #{_ptr: buf, _len: total, _cap: total}

    fn trim(self) -> str
        let s = self.as_str()
        let ts = _trim_start_str(s.as_ptr(), s.len())
        _trim_end_str(ts.as_ptr(), ts.len())

    fn trim_start(self) -> str
        _trim_start_str(self._ptr, self._len)

    fn trim_end(self) -> str
        _trim_end_str(self._ptr, self._len)

    fn drop(mut self)
        if self._ptr.is_null() == false
            free(self._ptr as Ptr[{}])
