import ffi.*
import str.*
import option.*
import array.*

pub struct String
    _ptr: Ptr[u8]
    _len: usize
    _cap: usize

impl String
    fn new() -> String
        String #{_ptr: 0 as Ptr[u8], _len: 0, _cap: 0}

    fn from(s: str) -> String
        let len = s.len()
        if len == 0
            return String.new()
        let buf = malloc(len) as Ptr[u8]
        memcpy(buf as Ptr[{}], s.as_ptr() as Ptr[{}], len)
        String #{_ptr: buf, _len: len, _cap: len}

    fn len(self) -> usize
        self._len

    fn is_empty(self) -> bool
        self._len == 0

    fn push(mut self, s: str)
        let src_len = s.len()
        if src_len == 0
            return
        let new_len = self._len + src_len
        if new_len > self._cap
            let mut new_cap = self._cap * 2
            if new_len > new_cap
                new_cap = new_len
            self._ptr = realloc(self._ptr as Ptr[{}], new_cap) as Ptr[u8]
            self._cap = new_cap
        memcpy(self._ptr.offset(self._len) as Ptr[{}], s.as_ptr() as Ptr[{}], src_len)
        self._len = new_len

    fn as_str(self) -> str
        str_from_raw(self._ptr, self._len)

    fn byte_at(self, i: usize) -> u8
        self._ptr.offset(i).read()

    fn contains(self, s: str) -> bool
        _bytes_contains(self._ptr, self._len, s.as_ptr(), s.len())

    fn starts_with(self, s: str) -> bool
        _bytes_starts_with(self._ptr, self._len, s.as_ptr(), s.len())

    fn ends_with(self, s: str) -> bool
        _bytes_ends_with(self._ptr, self._len, s.as_ptr(), s.len())

    fn substring(self, start: usize, end: usize) -> str
        str_from_raw(self._ptr.offset(start), end - start)

    fn clear(mut self)
        self._len = 0

    fn repeat(self, n: usize) -> String
        let total = self._len * n
        if total == 0
            return String.new()
        let buf = malloc(total) as Ptr[u8]
        let mut i: usize = 0
        while i < n
            memcpy(buf.offset(i * self._len) as Ptr[{}], self._ptr as Ptr[{}], self._len)
            i = i + 1
        String #{_ptr: buf, _len: total, _cap: total}

    fn trim(self) -> str
        let s = self.as_str()
        let ts = _trim_start_str(s.as_ptr(), s.len())
        _trim_end_str(ts.as_ptr(), ts.len())

    fn trim_start(self) -> str
        _trim_start_str(self._ptr, self._len)

    fn trim_end(self) -> str
        _trim_end_str(self._ptr, self._len)

    fn index_of(self, needle: str) -> Option[usize]
        let pos = _bytes_index_of(self._ptr, self._len, needle.as_ptr(), needle.len())
        if pos >= 0
            Option[usize].Some(pos as usize)
        else
            Option[usize].None

    fn split(self, sep: str) -> Array[str]
        let mut result: Array[str] = Array[str].new()
        let sep_len = sep.len()
        if sep_len == 0
            result.push(self.as_str())
            return result
        let mut start: usize = 0
        while start <= self._len
            let remaining = self._len - start
            let pos = _bytes_index_of(self._ptr.offset(start), remaining, sep.as_ptr(), sep_len)
            if pos >= 0
                result.push(str_from_raw(self._ptr.offset(start), pos as usize))
                start = start + (pos as usize) + sep_len
            if pos < 0
                result.push(str_from_raw(self._ptr.offset(start), remaining))
                start = self._len + 1
        result

    fn replace(self, old: str, new_str: str) -> String
        let mut result = String.new()
        let old_len = old.len()
        if old_len == 0
            return String.from(self.as_str())
        let mut start: usize = 0
        while start < self._len
            let remaining = self._len - start
            let pos = _bytes_index_of(self._ptr.offset(start), remaining, old.as_ptr(), old_len)
            if pos < 0
                result.push(str_from_raw(self._ptr.offset(start), remaining))
                start = self._len
            if pos > 0
                result.push(str_from_raw(self._ptr.offset(start), pos as usize))
            if pos >= 0
                result.push(new_str)
                start = start + (pos as usize) + old_len
        result

    fn to_uppercase(self) -> String
        if self._len == 0
            return String.new()
        let buf = malloc(self._len) as Ptr[u8]
        _to_uppercase(self._ptr, self._len, buf)
        String #{_ptr: buf, _len: self._len, _cap: self._len}

    fn to_lowercase(self) -> String
        if self._len == 0
            return String.new()
        let buf = malloc(self._len) as Ptr[u8]
        _to_lowercase(self._ptr, self._len, buf)
        String #{_ptr: buf, _len: self._len, _cap: self._len}

    fn push_string(mut self, other: String)
        let src_len = other._len
        if src_len == 0
            return
        let new_len = self._len + src_len
        if new_len > self._cap
            let mut new_cap = self._cap * 2
            if new_len > new_cap
                new_cap = new_len
            self._ptr = realloc(self._ptr as Ptr[{}], new_cap) as Ptr[u8]
            self._cap = new_cap
        memcpy(self._ptr.offset(self._len) as Ptr[{}], other._ptr as Ptr[{}], src_len)
        self._len = new_len

    fn hash(self) -> u64
        self.as_str().hash()

    fn drop(mut self)
        if self._ptr.is_null() == false
            free(self._ptr as Ptr[{}])
