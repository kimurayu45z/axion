import ffi.*

pub fn str_from_raw(ptr: Ptr[u8], len: usize) -> str
    "intrinsic"

fn _is_whitespace(b: u8) -> bool
    b == (32 as u8) || b == (9 as u8) || b == (10 as u8) || b == (13 as u8)

pub(pkg) fn _trim_start_str(ptr: Ptr[u8], len: usize) -> str with Unsafe
    let mut i: usize = 0
    while i < len
        if _is_whitespace(ptr.offset(i).read()) == false
            return str_from_raw(ptr.offset(i), len - i)
        i = i + 1
    str_from_raw(ptr.offset(len), 0)

pub(pkg) fn _trim_end_str(ptr: Ptr[u8], len: usize) -> str with Unsafe
    let mut i = len
    while i > 0
        if _is_whitespace(ptr.offset(i - 1).read()) == false
            return str_from_raw(ptr, i)
        i = i - 1
    str_from_raw(ptr, 0)

pub(pkg) fn _bytes_contains(hay: Ptr[u8], hay_len: usize, needle: Ptr[u8], needle_len: usize) -> bool with Unsafe
    if needle_len == 0
        return true
    if needle_len > hay_len
        return false
    let end = hay_len - needle_len + 1
    let mut i: usize = 0
    while i < end
        if memcmp(hay.offset(i) as Ptr[{}], needle as Ptr[{}], needle_len) == 0
            return true
        i = i + 1
    false

pub(pkg) fn _bytes_starts_with(hay: Ptr[u8], hay_len: usize, prefix: Ptr[u8], prefix_len: usize) -> bool with Unsafe
    if prefix_len > hay_len
        return false
    if prefix_len == 0
        return true
    memcmp(hay as Ptr[{}], prefix as Ptr[{}], prefix_len) == 0

pub(pkg) fn _bytes_ends_with(hay: Ptr[u8], hay_len: usize, suffix: Ptr[u8], suffix_len: usize) -> bool with Unsafe
    if suffix_len > hay_len
        return false
    if suffix_len == 0
        return true
    memcmp(hay.offset(hay_len - suffix_len) as Ptr[{}], suffix as Ptr[{}], suffix_len) == 0

pub(pkg) fn _bytes_index_of(hay: Ptr[u8], hay_len: usize, needle: Ptr[u8], needle_len: usize) -> isize with Unsafe
    if needle_len == 0
        return 0
    if needle_len > hay_len
        return 0 - 1
    let end = hay_len - needle_len + 1
    let mut i: usize = 0
    while i < end
        if memcmp(hay.offset(i) as Ptr[{}], needle as Ptr[{}], needle_len) == 0
            return i as isize
        i = i + 1
    0 - 1

pub(pkg) fn _to_uppercase(src: Ptr[u8], len: usize, dst: Ptr[u8]) with Unsafe
    let mut i: usize = 0
    while i < len
        let b = src.offset(i).read()
        if b >= (97 as u8) && b <= (122 as u8)
            dst.offset(i).write(b - (32 as u8))
        else
            dst.offset(i).write(b)
        i = i + 1

pub(pkg) fn _to_lowercase(src: Ptr[u8], len: usize, dst: Ptr[u8]) with Unsafe
    let mut i: usize = 0
    while i < len
        let b = src.offset(i).read()
        if b >= (65 as u8) && b <= (90 as u8)
            dst.offset(i).write(b + (32 as u8))
        else
            dst.offset(i).write(b)
        i = i + 1
