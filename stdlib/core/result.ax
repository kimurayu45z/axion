pub enum Result[T, E]
    Ok(value: T)
    Err(error: E)

impl[T, E] Result[T, E]
    fn unwrap_or(self, default: T) -> T
        match self
            Result[T, E].Ok(v) =>
                v
            Result[T, E].Err(_) =>
                default

    fn map[U](self, f: Fn(T) -> U) -> Result[U, E]
        match self
            Result[T, E].Ok(v) =>
                Result[U, E].Ok(f(v))
            Result[T, E].Err(e) =>
                Result[U, E].Err(e)

    fn and_then[U](self, f: Fn(T) -> Result[U, E]) -> Result[U, E]
        match self
            Result[T, E].Ok(v) =>
                f(v)
            Result[T, E].Err(e) =>
                Result[U, E].Err(e)

    fn map_err[F](self, f: Fn(E) -> F) -> Result[T, F]
        match self
            Result[T, E].Ok(v) =>
                Result[T, F].Ok(v)
            Result[T, E].Err(e) =>
                Result[T, F].Err(f(e))

    fn or(self, other: Result[T, E]) -> Result[T, E]
        match self
            Result[T, E].Ok(v) =>
                Result[T, E].Ok(v)
            Result[T, E].Err(_) =>
                other

    fn or_else(self, f: Fn(E) -> Result[T, E]) -> Result[T, E]
        match self
            Result[T, E].Ok(v) =>
                Result[T, E].Ok(v)
            Result[T, E].Err(e) =>
                f(e)

    fn is_ok(self) -> bool
        match self
            Result[T, E].Ok(_) =>
                true
            Result[T, E].Err(_) =>
                false

    fn is_err(self) -> bool
        match self
            Result[T, E].Ok(_) =>
                false
            Result[T, E].Err(_) =>
                true
