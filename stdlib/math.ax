fn abs[T: SInt](x: T) -> T
    if x < 0
        0 - x
    else
        x

fn min[T: Number](a: T, b: T) -> T
    if a < b
        a
    else
        b

fn max[T: Number](a: T, b: T) -> T
    if a > b
        a
    else
        b

fn clamp[T: Number](x: T, lo: T, hi: T) -> T
    if x < lo
        lo
    else
        if x > hi
            hi
        else
            x

fn sign[T: SInt](x: T) -> T
    if x > 0
        1
    else
        if x < 0
            0 - 1
        else
            0

fn pow[T: Int](base: T, exp: T) -> T
    let mut result = 1
    let mut i = 0
    while i < exp
        result = result * base
        i = i + 1
    result

fn gcd[T: SInt](a: T, b: T) -> T
    let mut x = abs[T](a)
    let mut y = abs[T](b)
    while y > 0
        let t = y
        y = x % t
        x = t
    x

fn lcm[T: SInt](a: T, b: T) -> T
    let g = gcd[T](a, b)
    if g == 0
        0
    else
        abs[T](a) / g * abs[T](b)

fn is_even[T: Int](x: T) -> bool
    if x % 2 == 0
        true
    else
        false

fn is_odd[T: Int](x: T) -> bool
    if x % 2 == 0
        false
    else
        true
